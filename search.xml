<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DTD可以限制XML啥？]]></title>
    <url>%2F2017%2F12%2F20%2FDTD%E5%8F%AF%E4%BB%A5%E9%99%90%E5%88%B6XML%E5%95%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[DTDDTD语法 &lt;!ELEMENT 元素名称 约束&gt; dtd: 复杂元素：有子标签&lt;!ELEMENT person(name, age)&gt;，简单元素：没子标签&lt;!ELEMENT name(#PCDATA) ###约束类型： PCDATA: 字符串类型EMPTY: 空类型ANY: 任何类型 ###表示子元素出现的次数： +: 一次或多次?: 零次或一次*: 零次或多次 ###表示子元素的顺序： ,: 遵守孙旭|：无序 ###元素属性： CDATA: 字符串类型枚举：只能在一定的范围内出现值，每次只能出现一个(aa|bb|cc)ID：值只能是字母或下划线开头 ###元素属性约束： 井EQUIRED: 必须的 井IMPLIED: 可有可无 井FIXED: 取值为一个固定值 ###定义实体： !ENTITY TEST “HAHA”&TEST; //使用实体 CDATA消除义使用&lt;![CDTA[str]]不转义特殊字符.]]></content>
  </entry>
  <entry>
    <title><![CDATA[schema是什么东东？]]></title>
    <url>%2F2017%2F12%2F20%2Fschema%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E4%B8%9C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[XML Schema###创建一个Schama文件 Schama就是一个XML文件，后缀名是xsd. 根节点： ####节点属性： xmlns=”http://www.w3.org/2001/XMLSchema“ 表示他是约束文档. targetNamespace=”ethanway.github.io” 直接通过这个地址引入约束文件，一般用url地址来表示.保证没有重复的. elementFormDefault=”qualified” qualified：质量良好的 ####元素类型： 通过element标签里的type属性设置.int string ####复杂元素定义： 1&lt;element name=""&gt;&lt;complexType&gt;&lt;sequence&gt;子元素&lt;/sequence&gt;&lt;/complexType&gt;&lt;/element&gt; 表示元素是有顺序的. 只能出现一次. 只能出现其中的一个，多选1 表示任意元素 element元素属性maxOccurs=”unbounded”设置该元素无限制使用. #####定义属性：只能为复杂元素···html 1234567* #####use属性：* required：必须存在的####简单元素定义：​```html&lt;element name=&quot;&quot; type=&quot;&quot;&gt;&lt;/element&gt; XML中引入Schema文件. 在根标签中添加属性 xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance“ : 表示是一个被约束的文件 xmlns=”you file namespace” : 你的Schema文件命名空间 xsI:schemaLocation=”namespace filename” : 你的Schama文件命名空间和路径 引入多个schama文件，可以给每个起别名。想使用哪个schema文件中的元素就使用哪个别名来调用： ##DOM解析方式 DOM：根据xml的层级结构在内存中分配一个树形结构.把xml中标签，属性，文本封装成对象. ###获取节点1234567891011DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();// 获取DocumentBuilder实例DocumentBuilder db = dbf.newDocumentBuilder();// 解析xml文件Document doc = db.parse("src/person.xml");NodeList names = doc.getElementsByTagName("name");for (int i = 0; i &lt; names.getLength(); i++) &#123; // item选择单个元素 Node name = names.item(i); System.out.println(name.getTextContent());&#125; ###文档回写123TransformerFactory tf = TransformerFactory.newInstance();Transformer t = tf.newTransformer();t.transform(new DOMSource(doc), new StreamResult("src/person.xml")); ###修改节点12Node sex = document.getElementsByTagName("sex").item(0);sex.setTextContent("123"); ###删除节点123456// 找到sex节点NodeList sexs = document.getElementsByTagName("sex");Node sex = sexs.item(0);// 获取父节点Node p1 = sex.getParentNode();p1.removeChild(sex); ##Sax解析 解析xml有两种技术，DOM/Sax。 SAX：事件驱动，边读边解析 在java.xml.parsers SAXParser SAXParserFactory ###Sax解析的过程 执行parse(url, 事件处理器)方法. 当把事件处理器传递进来，相当于在方法里面绑定了一个事件。 事件处理器方法： 自己创建一个类继承DefaultHander 实现》 执行到开始标签自动调用：startElement() 执行到文本标签自动调用：characters() 执行到结尾标签自动调用：endElement() ###查找节点(只能做查询操作) SAXParser(url, 事件处理器)]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的JavaWeb学习路线]]></title>
    <url>%2F2017%2F12%2F19%2F%E6%88%91%E7%9A%84JavaWeb%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[我的JavaWeb学习路线 第一阶段: Java 基础，包括 Java 语法，面向对象特征，常见API，集合框架。(基础） 第二阶段:Java API：输入输出，多线程，网络编程，反射注解等，Java 的精华部分。(重点) 第三阶段:数据库 SQL 基础，包括增删改查操作以及多表查询。Oracle Mysql 二选一吧。(我的项目都是用的 Mysql 第四阶段: JDBC 编程:包括 JDBC 原理， JDBC 连接库， JDBC API，虽然现在 Hibernate 比 JDBC 要方便许多，但是 JDBC 技术仍然在使用， JDBC 思想尤为重要。 第五阶段: JDBC 深入理解高级特性：包括数据库连接池，存储过程，触发器， CRM 思想(高级)这个比较不好懂，有时间的可以学习。 第六阶段: Servlet 开发，从此开始踏入 JavaWeb 开发的重要一步，包括XML， Tomcat 服务器的安装使用操作， HTTP 协议简单理解，Servlet API 等， Java Web 开发的基础。(重要) 第七阶段: JSP 开发: JSP 语法和标签，自定义标签， EL , JSTL 库了解以及 MVC 三层架构的设计模式理念。 第八阶段:三大框架- Spring 、 SpringMVC 、 MyBatis ， JavaWeb 的精华部分(重要) 第九阶段:当学习完这些知识后，你就可以深层次的学习一些企业框架， Maven 、 redis 、 log4j 等等。]]></content>
  </entry>
  <entry>
    <title><![CDATA[css3 border-radius属性详解]]></title>
    <url>%2F2017%2F12%2F19%2Fcss3-border-radius%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CSS3详解##CSS3圆角属性 1border-radius: 10px 20px 30px 40px 这四个参数分别对应左上，右上，右下，左下四个角的弧度. 气球CSS设置：160px 160px 64px 160px; CSS3旋转1transform: rotate(45deg); 顺时针旋转45°. CSS3盒子阴影1box-shadow 0 0 65px 20px #ffffff inset|outset; 设置阴影：外阴影，内阴影. 参数1：影子的x坐标 参数2：影子的y坐标 参数3：影子的模糊程度 参数4：影子的粗细 参数5：影子的颜色 参数6：内阴影还是外阴影. CSS3伪元素 after before 伪元素区别与伪类 伪类：不添加标签 伪元素：真真实实的添加了一个标签. 使用content激活伪元素 伪元素默认为行内样式，width和height无法改变其大小.，需要使用display:block.设置其为块样式. CSS3三角形 设置四个宽边框，把其他三个角设置为透明色，transparent，只设置当前角的颜色.]]></content>
  </entry>
  <entry>
    <title><![CDATA[JQueryDOM操作]]></title>
    <url>%2F2017%2F12%2F19%2FJQueryDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[[TOC] #节点操作 查找节点 查找属性节点：通过JQuery选择器完成.查找属性节点：查找到所需要的元素之后，可以调用JQuery对象的attr()方法来获取它的各种属性值.操作文本节点: 通过text().123$("p").text("Ethan");$("p").attr("user", "1779956562")alert($("p").attr("user")); 创建节点 使用JQuery的工厂函数$(): #(html); 会根据传入的html标记字符串创建一个DOM对象，并把这个DOM包装成一个JQuery对象返回. 动态创建的新元素节点不会被自动添加到文档中，而是需要使用其他方法将其插入到文档中; 当创建单个元素时，需注意闭合标签使用标准的XHTML格式，例如创建一个p元素，可以使用(““)或$(““)，必须要加上闭合符号. 创建文本节点就是fsdf，创建属性节点同上. 插入节点 方法 描述 append 向每个匹配的元素的内部的结尾处追加内容 appendTo 将每个匹配的元素追加到指定的元素内部的结尾处. prepend 向每个匹配元素的内部的开始处插入内容. prependTo 将每个匹配的元素插入到指定的元素内部的开始处 after 当前元素插入到指定元素后面 insertafter 当前元素的后面插入指定元素 befor 前面 insertbefor 前面]]></content>
  </entry>
  <entry>
    <title><![CDATA[JQuery选择器：我的JQuery兄弟.]]></title>
    <url>%2F2017%2F12%2F19%2FJQuery%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%9A%E6%88%91%E7%9A%84JQuery%E5%85%84%E5%BC%9F%2F</url>
    <content type="text"><![CDATA[#我的JQuery兄弟 由JQuery对象转为DOM对象 获取一个JQuery对象 1var $btn = $("button"); JQuery对象是一个数组 1alert($btn.length); JQuery对象可以通过数组下标获取DOM对象 1alert($btn[0].firstChild.nodeValue); 由DOM对象转为JQuery对象 text()也可以修改文本节点内容.12// 使用$()包裹DOM对象alert($(btn).text()); //等价于: btn.firstChild.nodeValue; 基本选择器 ID选择器 # 1$("#btn"); class选择器 [ . ] 1$(".btn"); 标签选择器 button 1$("button"); 全部选择 [ * ] 1$("*"); 多选，并列选择器 , 1$(".btn,button,#btn"); ##层次选择器 选取ancestor的所有descendant(后代)元素 后代元素：包括子元素的子元素。。。 1$("ancestor descendant"); 选取ancestor的所有descendant(子)元素 子元素：只包括他下面的元素。。。 1$("ancestor&gt;descendant"); 选取ancestor的下一个descendant元素 以下选择器仅在descendant和ancestor相邻的才有效. 1$("ancestor+descendant"); 选取ancestor后面的所有descendant元素 1$("ancestor~descendant"); 选取ancestor所有兄弟descendant元素 1$("ancestor").sibling("descendant"); 选取不相邻ancestor的下一个兄弟descendant元素 first代表的是第一个元素 1$("ancestor").nextAll("descendant:first"); 选取ancestor前面的所有兄弟descendant元素 1$("ancestor").prevAll("descendant"); 基本过滤选择器 过滤选择器主要是通过特定的过滤规则来筛选出所需的DOM元素，该选择器都以“:”开头. 按照不同的过滤规则，过滤选择器可以分为基本过滤，内容过滤，可见性过滤，属性过滤，子元素过滤和表单对象属性过滤选择器.选择器|描述|返回——|————|——–:first|选取第一个元素|单个元素组成的集合:last|选取最后一个元素|集合元素:not(selector)|去除所有与给定选择器匹配的元素|集合元素:even|选取索引时偶数的所有元素，索引从0开始|集合元素:odd|选取索引时奇数的所有元素，索引从0开始|集合元素:eq(index)|选取索引大于等于index的元素，索引从0开始|集合元素:gt(index)|选取索引大于index的元素，索引从0开始|集合元素:lt(index)|选取索引小于index的元素，索引从0开始|集合元素:header|选取所有的标题元素，如：h1，h2等|集合元素:animated|选取当前正在执行动画的所有元素|集合元素 123456789101112131415161718192021222324252627282930313233$("#btn1").click(function () &#123; $("div:first").css("background", "orange");&#125;)$("#btn2").click(function () &#123; $("div:last").css("background", "orange");&#125;)$("#btn3").click(function () &#123; $("div:not(.one)").css("background", "orange");&#125;)$("#btn4").click(function () &#123; $("div:even").css("background", "orange");&#125;)$("#btn5").click(function () &#123; $("div:odd").css("background", "orange");&#125;)$("#btn6").click(function () &#123; $("div:gt(3)").css("background", "orange");&#125;)$("#btn7").click(function () &#123; $("div:eq(3)").css("background", "orange");&#125;)$("#btn8").click(function () &#123; $("div:lt(3)").css("background", "orange");&#125;)$("#btn9").click(function () &#123; $(":header").css("background", "orange");&#125;)$("#btn10").click(function () &#123; $(":animated").css("background", "orange");&#125;)$("#btn11").click(function () &#123; $("#two").nextAll("span:first").css("background", "orange");&#125;) 内容过滤选择器 内容过滤选择器的过滤规则主要体现在他所包含的子元素和文本内容上选择器|描述|返回 ——|—-|—-:contains(text)|选取含有文本内容为text的元素|集合元素:empty|选取不包含子元素或者文本的空元素|集合元素:has(selector)|选取含有某个选择器的元素|集合元素:parent|选取含有子元素或文本的元素|集合元素 可见性过滤选择器 可见性过滤选择器是根据元素的可见和不可见状态来选择相应的元素可见选择器：hidden不仅包含样式属性display为none的元素，也包括文本隐藏域()和visible:hidden之类的元素.选择器|描述|返回——|—-|—-:hidden|选取所有不可见的元素|集合元素:visible|选取所有可见的元素|集合元素 属性过滤选择器属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素.选择器|描述|返回——|—-|—-]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub Page建立博客]]></title>
    <url>%2F2017%2F12%2F19%2F%E4%BD%BF%E7%94%A8GitHub-Page%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[[TOC] 安装HexoHexo目录结构_config.yml _config.yml配置教程 网站的配置信息，可以在此配置大部分的参数.package.json 应用程序的信息。EJS,Stylus和Markdown renderer以默认安装，可以自由移除.scaffolds 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。source 资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。themes 主题文件夹。Hexo会根据主题来生成静态页面. Hexo使用开启服务器 hexo server localhost:4000 访问 NexT主题使用切换主题 修改配置文件theme.设置菜单 文章编写编写提交一个文章 hexo new post “title” 去本地目录编写md代码. hexo g hexo d hexo deploy]]></content>
  </entry>
</search>
